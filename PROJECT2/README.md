# 현재 진행 상황
student_score.dart(필수 과제)까지는 완료했지만,
student_analyzer.dart(도전 과제: 전체 평균 / 우수생 탐색 기능)**은 아직 구현 중인 상태

### 1. student_score.dart
#### 학생 성적 분석
Dart 기본 문법과 파일 입출력, 클래스 상속을 활용하여
학생 성적 분석 프로그램을 구현
#### 구현 기능
1. Score 클래스 구현
점수(int)를 저장하고 출력하는 기능 제공
2. StudentScore 클래스 구현
3. students.txt 파일 읽기
4. 사용자 입력을 통한 학생 검색
5. 결과를 파일(result.txt)에 저장

### 2. student_analyzer.dart
추후 작성 예정



---

# Git 업로드 과정에서 발생한 문제와 해결 과정 정리
프로젝트를 GitHub에 업로드하는 과정에서 몇 가지 문제가 발생했는데, 그 원인과 해결 과정을 정리

또한 동일한 문제가 반복되지 않도록 Git의 기본 개념과 명령어도 함께 정리

### 1. 문제 원인

#### 1) 프로젝트 내부에 Git 저장소가 중첩된 상태
프로젝트 최상위 폴더에 이미 `.git` 디렉터리가 있었는데,

그 안의 하위 폴더(예: PROJECT2)에도 또 다른 `.git` 디렉터리가 존재하고 있었음

이렇게 Git 저장소가 중첩되면 Git이 이를 별도의 저장소 또는 서브모듈로 인식하게 되어,

업로드 과정에서 경고가 발생한다고 함

이 구조는 일반적인 단일 저장소 구조와 충돌을 일으켜 push 과정에도 영향을 줌

#### 2) GitHub 저장소 내용과 로컬 저장소의 이력 불일치
이미 GitHub 원격 저장소에는 기존 커밋 기록이 있었고,

로컬에서는 폴더 구조를 바꾸고 파일을 새로 정리한 상태였음

두 저장소의 이력이 서로 다르게 진행되어 있었기 때문에, push 시 다음과 같은 오류가 발생했음

```
error: failed to push some refs
Updates were rejected because the remote contains work that you do not have locally.
```

너의 로컬 파일이 원격 저장소의 히스토리를 포함하고 있지 않아

그러니까 push 못 해!

먼저 원격 저장소 내용을 받아와서 합쳐!

-> 원격 저장소 내용을 먼저 받아오고 병합해야 push가 가능한 상황이었음

---

### 2. 해결 과정

#### 1) 내부에 중첩된 Git 저장소 제거
하위 폴더에 존재하던 `.git` 디렉터리를 삭제하고,
Git이 해당 폴더를 저장소로 인식하지 않도록 했음

```
git rm --cached -r PROJECT2
```
→ Git에게 “이 폴더를 Git의 추적 대상에서 빼줘”라고 말하는 것

이후 실제 `.git` 폴더를 수동으로 삭제하여 폴더를 일반 디렉터리 상태로 되돌렸음
  
  ->“여기는 저장소 아님!” 이라고 되돌린 것

##### =>프로젝트 전체가 하나의 Git 저장소가 됨

#### 2) 원격 저장소와의 병합
로컬과 원격의 이력이 달라 직접 병합을 진행해야 했기 때문에, 다음 명령어를 사용하여 GitHub의 최신 내용을 받아왔음

```
git pull origin main --allow-unrelated-histories
```
->두 이력은 서로 상관이 없지만, 억지로라도 합쳐줘!

이 명령어는 서로 관련 없는 두 히스토리를 강제로 통합할 때 사용함

-원격 내용을 가져오고
충돌이 없다면 자동 병합되고

편집창이 열려서 “이 병합을 왜 하는지 commit 메시지 쓰세요” 나오는데
그냥 저장하고 닫으면 병합 완료

병합이 되면 로컬과 원격의 역사(커밋)가 동일해져서 push가 가능해짐

머지 메시지가 열리면 저장 후 종료하여 병합을 완료

### 3) 병합 완료 후 정상적으로 push
병합 후 정리된 커밋을 다시 원격 저장소로 push하여 업로드를 완료

```
git push origin main
```

---

## 3. Git 기본 개념 및 명령어 정리

### git status

현재 파일 상태를 확인한다. (변경됨, 삭제됨 등)

### git add .

변경된 파일 전체를 스테이징 영역에 올린다.

### git commit -m "메시지"

작업 내용을 기록한다.

### git pull origin main

원격 저장소의 최신 내용을 받아온다.

### git push origin main

로컬의 커밋을 원격 저장소에 업로드한다.

---

## 4. 같은 문제가 반복되지 않도록 하기 위한 방법

1. 한 프로젝트 안에서는 git init을 한 번만 사용하자
   하위 폴더에서는 절대로 git init을 실행하지 않기

2. 새로운 프로젝트를 시작할 때는 가능하면 GitHub에서 clone으로 시작하자

   ```
   git clone <저장소 주소>
   ```

   **git clone :**
   “GitHub에 있는 이 프로젝트를 내 컴퓨터로 그대로 데려와줘.”

   clone을 하면 좋은 점:
   이미 GitHub에서 정상적으로 저장소가 만들어진 상태를 그대로 가져옴

   * .git이 깨끗하고
   * 폴더 구조도 제대로 잡혀 있고
   * 원격(remote) 연결도 자동으로 설정됨

   → 문제가 생길 확률이 낮아짐



### #### init VS clone

#### - git init → “빈 노트 시작”

* 내가 직접 하나하나 설정해줘야 함
* 원격 저장소 연결
* 브랜치 설정
* .gitignore 설정
* 폴더 구조 정리
* 실수하면 git 저장소 중첩 발생

#### - git clone → “이미 다 세팅된 노트 복사해서 시작”

GitHub에서 만든 저장소를 그대로 가져오니까:

* Git 설정 완료
* 원격 연결 완료
* 브랜치 자동 생성
* 파일 구조도 그대로

그리고 clone은 하위 폴더에 또 git init 할 일이 없음
→ 구조가 꼬이지 않음



##### => 지금 내가 생각하는 가장 안전한 시작 방식(?)

GitHub → 새 저장소 만들기

↓

로컬에 clone

↓

```
git clone https://github.com/JIMIN0001/project.git
```


3. push 전 기본 절차

   ```
   git status
   git add .
   git commit -m "메시지"
   git pull origin main
   git push origin main
   ```
    * pull 먼저 → push 나중
